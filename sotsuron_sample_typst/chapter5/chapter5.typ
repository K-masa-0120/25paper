= 実験結果と考察
//それぞれの比較じゃなくて、１つのグラフに対して何に着目すべきかを書く。
== 実験1
=== 結果
実験1の環境における正規化入力の結果を@fig:51 と@tbl:5-1 、モジュロ演算入力の結果を@fig:52 と@tbl:5-2、インデックス指定値入力の結果を@fig:53 と@tbl:5-3、従来のDQNモデルの結果を@fig:54 と@tbl:5-4 に示す。

#figure(
  caption:[実験1、正規化入力のグラフ],
  image("../img/page5-1Nomalize .png",height: 460pt)
)<51>

#figure(
  caption:[実験1、モジュロ演算入力のグラフ],
  image("../img/page5-2mono.png",height: 460pt)
)<52>

#figure(
  caption:[実験1、インデックス指定値入力のグラフ],
  image("../img/page5-3index.png",height: 460pt)
)<53>

#figure(
  caption:[実験1、従来DQNのグラフ],
  image("../img/page5-4.png",height: 460pt)
)<54>

\ \ \
表に示す数値のうち、総移動時間は単位時間の累計であり、経路一致は一致回数である。また、完全一致と部分一致は重複した累計で表示されている。
#figure(
  caption: [実験1、正規化入力の結果],
  table(
    columns: 2,
    table.header([計測種類],[カウント]),
    [総移動時間], [92052],
    [完全一致＃1], [1594],
    [完全一致＃2], [1617],
    [完全一致＃3], [1492],
    [部分一致＃1], [1713],
    [部分一致＃2], [1728],
    [部分一致＃3], [1594],
    )
)<5-1>
#figure(
  caption: [実験1、モジュロ演算入力の結果],
  table(
    columns: 2,
    table.header([計測種類],[カウント]),
    [総移動時間], [91796],
    [完全一致＃1], [1590],
    [完全一致＃2], [1607],
    [完全一致＃3], [1513],
    [部分一致＃1], [1715],
    [部分一致＃2], [1706],
    [部分一致＃3], [1621],
    )   
)<5-2>
#figure(
  caption: [実験1、インデックス指定値入力の結果],
  table(
    columns: 2,
    table.header([計測種類],[カウント]),
    [総移動時間], [93427],
    [完全一致＃1], [1660],
    [完全一致＃2], [1982],
    [完全一致＃3], [1057],
    [部分一致＃1], [1783],
    [部分一致＃2], [2121],
    [部分一致＃3], [1127],
    )
)<5-3>
#figure(
  caption: [実験1、従来DQNの結果],
  table(
    columns: 2,
    table.header([計測種類],[カウント]),
    [総移動時間], [124765],
    [完全一致＃1], [1242],
    [完全一致＃2], [1359],
    [完全一致＃3], [1231],
    [部分一致＃1], [1701],
    [部分一致＃2], [1826],
    [部分一致＃3], [1671],
    )
)<5-4>

=== 考察
ホップ数のグラフを比較したとき、従来のDQN(@fig:54)では6万カウント以降で収束に向かっているが、提案手法の3種類(@fig:51 @fig:52 @fig:53)の方では2万カウント近辺で収束が開始している。これに加え、総移動時間数も提案手法(@tbl:5-1@tbl:5-2@tbl:5-3)が9万カウント台に対し、DQN(@tbl:5-4)が12万カウント台に乗っていることから、提案手法の方が環境に対し迅速な対応ができていることが分かる。

完全一致、部分一致の観点から比較したとき、正規化入力(@fig:51)及びモジュロ演算入力(@fig:52)に対し、インデックス指定値入力(@fig:53)の方が部分一致の回数が多く、完全一致の数値にばらつきが見える。この挙動はインデックス指定値入力の学習では環境の周期変化に大きく依存した挙動であると考えられる。

また、正規化とモジュロ演算の結果を比較したとき、完全一致率で正規化がやや優位となる結果が得られた。以上のことより、今環境においては正規化入力のモデルの学習が安定した挙動を示し、3つの提案手法のうち優位な適応性を持つことが確認できた。

== 実験2
=== 結果
実験2の環境における正規化入力の結果を@fig:55 と@tbl:5-5、モジュロ演算入力の結果を@fig:56 と@tbl:5-6、インデックス指定値入力の結果を@fig:57 と@tbl:5-7、従来のDQNモデルの結果を@fig:58 と@tbl:5-8 に示す。
#figure(
  caption:[実験2、正規化入力のグラフ],
  image("../img/page5-5.png",height: 460pt)
)<55>

#figure(
  caption:[実験2、モジュロ演算入力のグラフ],
  image("../img/page5-6.png",height: 460pt)
)<56>

#figure(
  caption:[実験2、インデックス指定値入力のグラフ],
  image("../img/page5-7.png",height: 460pt)
)<57>

#figure(
  caption:[実験2、従来DQNのグラフ],
  image("../img/page5-8.png",height: 460pt)
)<58>

#pagebreak()
#figure(
  caption: [実験2、正規化入力の結果],
  table(
    columns: 2,
    table.header([計測種類],[カウント]),
    [総移動時間], [524173],
    [完全一致＃1], [1615],
    [完全一致＃2], [2550],
    [完全一致＃3], [1019],
    [部分一致＃1], [3366],
    [部分一致＃2], [4453],
    [部分一致＃3], [2462],
    )
)<5-5>

#figure(
  caption: [実験2、モジュロ演算入力の結果],
  table(
    columns: 2,
    table.header([計測種類],[カウント]),
    [総移動時間], [492539],
    [完全一致＃1], [1760],
    [完全一致＃2], [2757],
    [完全一致＃3], [772],
    [部分一致＃1], [3498],
    [部分一致＃2], [4642],
    [部分一致＃3], [2096],
    )
)<5-6>

#figure(
  caption: [実験2、インデックス指定値入力の結果],
  table(
    columns: 2,
    table.header([計測種類],[カウント]),
    [総移動時間], [669609],
    [完全一致＃1], [558],
    [完全一致＃2], [2511],
    [完全一致＃3], [1960],
    [部分一致＃1], [1895],
    [部分一致＃2], [4711],
    [部分一致＃3], [3638],
    )
)<5-7>

#figure(
  caption: [実験2、従来DQNの結果],
  table(
    columns: 2,
    table.header([計測種類],[カウント]),
    [総移動時間], [5719407],
    [完全一致＃1], [13],
    [完全一致＃2], [0],
    [完全一致＃3], [0],
    [部分一致＃1], [5187],
    [部分一致＃2], [652],
    [部分一致＃3], [330],
    )
)<5-8>

=== 考察
従来のDQNモデル(@fig:58 @tbl:5-8)では学習が発散してることが確認でき、今環境において適応性が低いことが分かる。

これに対し、提案手法において収束の面を考慮したとき、実験1とは異なり、インデックス指定値(@fig:57)、正規化(@fig:55)、モジュロ演算(@fig:56)の順番で収束が安定していることが分かる。しかし、正規化及びモジュロ演算では環境が変化した際に一度ホップ数が多くなり、もう一度収束していくという形になっている。これは環境が変化した際に再度探索を行い、学習を行っていると考えられる。

一致回数を含め比較した際、@tbl:5-5 および@tbl:5-7 から分かるように、インデックス指定値よりも正則化の方が一致数が多くなっているため、長期的な学習の安定性においては正則化入力の方が有用であると考えられる。



#pagebreak()